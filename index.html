<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="sizeoftank">
<meta property="og:url" content="http://sizeoftank.github.io/index.html">
<meta property="og:site_name" content="sizeoftank">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sizeoftank">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sizeoftank.github.io/">





  <title>sizeoftank</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sizeoftank</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2021/10/12/2021/2021-10-12-mermaid-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/12/2021/2021-10-12-mermaid-tutorial/" itemprop="url">介绍一个画图工具Mermaid</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-12T21:00:00+00:00">
                2021-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人笔记/" itemprop="url" rel="index">
                    <span itemprop="name">个人笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2021/10/12/2021/2021-10-12-mermaid-tutorial/" class="leancloud_visitors" data-flag-title="介绍一个画图工具Mermaid">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在软件开发的系统建模过程中，画图是一项重要且比较耗时的工作。<br>常用的画图工具有Microsoft Visio, draw.io, processon.com 等。<br>对于追求效率的程序员而言，使用鼠标拖动的效率始终不如通过一项语言来描述图形, 而mermaid正好提供了这种能力帮助我们快速的绘制系统图形, 并且能够很好地将其文档化。</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Mermaid是一个基于Javascript的图表和图表工具, 通过定义特定的语法, 自动渲染出一些复杂的软件图形。<br>该工具在2019年层获得了JS开源奖项中的 “最激动人心的技术”奖项。</p>
<p>目前能够支持的图形类别包括</p>
<ul>
<li>流程图</li>
<li>时序图</li>
<li>甘特图</li>
<li>UML类图</li>
<li>E-R图</li>
<li>状态图</li>
<li>饼图</li>
</ul>
<p>官方主页: <a href="https://github.com/mermaid-js/mermaid" target="_blank" rel="noopener">https://github.com/mermaid-js/mermaid</a><br>官方教程: <a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">https://mermaid-js.github.io/mermaid/#/</a><br>在线编辑: <a href="https://mermaid-js.github.io/mermaid-live-editor" target="_blank" rel="noopener">https://mermaid-js.github.io/mermaid-live-editor</a></p>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre class="mermaid">graph LR
B(开始) --> C{进行讨论}
C -->|分支A| D[结果A]
C -->|分支B| E[结果B]</pre>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">B(开始) --&gt; C&#123;进行讨论&#125;</span><br><span class="line">C --&gt;|分支A| D[结果A]</span><br><span class="line">C --&gt;|分支B| E[结果B]</span><br></pre></td></tr></table></figure>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><pre class="mermaid">sequenceDiagram
Y->>John: Hello 你好吗?
loop 
    John->>John: 想了一会儿
end
Note right of John: 理性思考!
John-->>Alice: 挺好!
John->>Bob: 那你咋样?
Bob-->>John: 也挺好的</pre>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Y-&gt;&gt;John: Hello 你好吗?</span><br><span class="line">loop </span><br><span class="line">    John-&gt;&gt;John: 对抗抑郁症</span><br><span class="line">end</span><br><span class="line">Note right of John: 理性思考!</span><br><span class="line">John--&gt;&gt;Alice: 挺好!</span><br><span class="line">John-&gt;&gt;Bob: 那你咋样?</span><br><span class="line">Bob--&gt;&gt;John: 也挺好的</span><br></pre></td></tr></table></figure>
<h4 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h4><pre class="mermaid">pie
  title 语言分布
  "JAVA" : 80
  "Python" : 15
  "Go" : 5</pre>

<h4 id="画个甘特图"><a href="#画个甘特图" class="headerlink" title="画个甘特图"></a>画个甘特图</h4><pre class="mermaid">gantt
section Section
UI设计: des0, 2021-11-01, 1d
概要设计 : des1, 2021-11-01, 1d
后端开发 : des3, after des1, 1d
前端开发 :  des4, after des1, 2d
接口联调 :  des5, after des4, 1d
集成测试 :  des6, after des5, 2d</pre>

<h3 id="工具集成"><a href="#工具集成" class="headerlink" title="工具集成"></a>工具集成</h3><h4 id="与Hexo集成"><a href="#与Hexo集成" class="headerlink" title="与Hexo集成"></a>与Hexo集成</h4><p><strong>1.安装渲染插件</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></p>
<p><strong>2.修改配置文件</strong><br>在根目录下的 _config.yml 文件添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: &quot;8.13.2&quot; # default v7.1.2 (可更改为最新的RELEASE版本号)</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">    #startOnload: true  // default true</span><br><span class="line">    theme: forest</span><br></pre></td></tr></table></figure>
<p><strong>3.修改JS文件</strong><br>在 /themes/next/layout/_partials/footer.swig 添加如下代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    if (window.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="与VSCode-Gitlab集成"><a href="#与VSCode-Gitlab集成" class="headerlink" title="与VSCode/Gitlab集成"></a>与VSCode/Gitlab集成</h4><p>与VSCode集成的方式也有好多种, 本人使用的是语法高亮插件+Markdown预览的方案, 安装下面两个插件就好了</p>
<ul>
<li>Markdown Preview Mermaid Support </li>
<li>Mermaid Markdown Syntax Highlighting</li>
</ul>
<p>集成到VSCode之后, 就可以通过Git来管理项目中的图形文档了<br>同时在Gitlab里面也是支持Markdown文件直接渲染出图形的</p>
<h4 id="私有化部署live-editor"><a href="#私有化部署live-editor" class="headerlink" title="私有化部署live-editor"></a>私有化部署live-editor</h4><p>参考github主页 <a href="https://github.com/mermaid-js/mermaid-live-editor" target="_blank" rel="noopener">https://github.com/mermaid-js/mermaid-live-editor</a> 使用 docker 方式私有化部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --publish 8000:80 ghcr.io/mermaid-js/mermaid-live-editor</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>更进一步的话，也可以探讨一下怎么跟其他的工具链结合起来使用，例如代码生成/文档图形自动生成等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2020/10/21/2020/2020-10-21-gcc-upgrade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/21/2020/2020-10-21-gcc-upgrade/" itemprop="url">CentOS中XGBoost安装失败问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-21T22:00:00+00:00">
                2020-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人笔记/" itemprop="url" rel="index">
                    <span itemprop="name">个人笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/10/21/2020/2020-10-21-gcc-upgrade/" class="leancloud_visitors" data-flag-title="CentOS中XGBoost安装失败问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>执行安装命令后报出各种编译错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xgboost</span><br></pre></td></tr></table></figure></p>
<p>查看官方文档要求如下</p>
<ol>
<li>A recent C++ compiler supporting C++11 (g++-5.0 or higher)</li>
<li>CMake 3.13 or higher.</li>
</ol>
<p>通常使用 yum groupinstall ‘Development Tools’ 安装的gcc为&lt;5.0的版本, 导致代码编译不了, 升级方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install centos-release-scl</span><br><span class="line">sudo yum install devtoolset-7-gcc*</span><br><span class="line">scl enable devtoolset-7 bash</span><br><span class="line">which gcc</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure>
<p>安装 cmake 版本 &gt;= 3.13 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install cmake3</span><br></pre></td></tr></table></figure>
<p>先替换 bash 中的 gcc 版本再执行 pip install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scl enable devtoolset-7 bash</span><br><span class="line">source .../venv/bin/activate</span><br><span class="line">pip install xgboost</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2020/07/25/2020/2020-7-26-sbt-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/25/2020/2020-7-26-sbt-source/" itemprop="url">SBT设置国内源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-25T22:00:00+00:00">
                2020-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人笔记/" itemprop="url" rel="index">
                    <span itemprop="name">个人笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/07/25/2020/2020-7-26-sbt-source/" class="leancloud_visitors" data-flag-title="SBT设置国内源">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[repositories]</span><br><span class="line">  local</span><br><span class="line">  maven-huawei: https://repo.huaweicloud.com/repository/maven/</span><br><span class="line">  ivy-huawei: https://repo.huaweicloud.com/repository/ivy/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]</span><br><span class="line">  typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">  sonatype-oss-releases</span><br><span class="line">  maven-central</span><br><span class="line">  sonatype-oss-snapshots</span><br></pre></td></tr></table></figure>
<p>添加JVM参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置该参数后才能使用REPO镜像</span><br><span class="line">-Dsbt.override.build.repos=true </span><br><span class="line"># (可选)选择配置REPO配置文件路径</span><br><span class="line">-Dsbt.repository.config=&lt;REPO_CONFIG_PATH&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2020/07/25/2020/2020-7-26-fuck-brew-git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/25/2020/2020-7-26-fuck-brew-git/" itemprop="url">Homebrew更换git源</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-25T22:00:00+00:00">
                2020-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人笔记/" itemprop="url" rel="index">
                    <span itemprop="name">个人笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/07/25/2020/2020-7-26-fuck-brew-git/" class="leancloud_visitors" data-flag-title="Homebrew更换git源">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="替换USTC源"><a href="#替换USTC源" class="headerlink" title="替换USTC源"></a>替换USTC源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line">export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles</span><br></pre></td></tr></table></figure>
<h5 id="还原默认设置"><a href="#还原默认设置" class="headerlink" title="还原默认设置"></a>还原默认设置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>
<h5 id="替换阿里云的源"><a href="#替换阿里云的源" class="headerlink" title="替换阿里云的源"></a>替换阿里云的源</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2018/04/15/2018/2018-04-15-python-skills-for-ops/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/2018/2018-04-15-python-skills-for-ops/" itemprop="url">写给运维的Python使用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T22:00:00+00:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/04/15/2018/2018-04-15-python-skills-for-ops/" class="leancloud_visitors" data-flag-title="写给运维的Python使用技巧">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Python这门语言应用广泛，不论是大数据，AI，Web开发，运维等领域对Python的应用都有不同的要求，本次分享主要针对Python在运维脚本中的应用介绍一些实战技巧</p>
<h4 id="PEP8-编码规范"><a href="#PEP8-编码规范" class="headerlink" title="PEP8 编码规范"></a>PEP8 编码规范</h4><p>PEP8 (Python 代码风格指南)，是通过编码风格上的一些要求，用于提高团队中的代码质量，通过规范约束加上静态代码检查(Flake8等)，也可避免一些比较低级的坑。</p>
<h4 id="代码编排"><a href="#代码编排" class="headerlink" title="代码编排"></a>代码编排</h4><p>主要是终结 tab 跟空格的争论，PEP8要求全部使用空格，在编辑器中设置 tab 自动替换空格即可 (由于解析器的原因，tab跟空格混用可能会出现解释失败的情况)<br>其他主要影响代码美观性，如空格，空行，注释等等，可参考阅读官方写的示例就好:<br><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>主要关注一下变量，方法等的命名方式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量大写</span></span><br><span class="line">USER_CONSTANT = <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类名: 首字母大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDetail</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 变量名称, 小写加下划线</span></span><br><span class="line">        self.user_name = <span class="string">'user'</span></span><br><span class="line">        <span class="comment"># 私有属性: 双下划线前缀</span></span><br><span class="line">        self.__encrpyped_password = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 函数/方法: 小写加下划线</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_roles</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有方法: 单下划线前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_encrypt_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h4 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h4><p>Flake8 提供了 PEP8 编码规范及代码静态检查等，可集成到 Sublime Text 等工具中(Python Flake8 Lint 插件)，或者直接在命令行执行 flake8 xxx.py<br>静态检查的好处主要是检查，能够在执行代码前发现一些低级的错误，例如使用未定义方法，未定义的变量等<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example.py:<span class="number">35</span>:<span class="number">5</span>: F821 undefined name <span class="string">'undefined_method'</span></span><br><span class="line">example.py:<span class="number">36</span>:<span class="number">9</span>: F821 undefined name <span class="string">'undefined_var'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h4><p>字符串可能是脚本中是最常用到的对象，指导思想就是不要自己写处理逻辑，尽量使用内建方法，正则表达式，模板格式化等方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用占位符格式化</span></span><br><span class="line"><span class="string">'ps -ef|grep %s'</span> % <span class="string">'java'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用字典进行格式化</span></span><br><span class="line"><span class="string">'ps -ef|grep %(keyword)s'</span> % &#123;<span class="string">'keyword'</span>: <span class="string">'java'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用 format 方法格式化</span></span><br><span class="line"><span class="string">'ps -ef|grep &#123;keyword&#125;'</span>.format(keyword=<span class="string">'java'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对于复杂一些的内容可以通过 Jinja2 来完成，例如生成一段 YML</span></span><br><span class="line">template = jinja2.Template(<span class="string">'\</span></span><br><span class="line"><span class="string">- hosts: &#123;&#123;project.name&#125;&#125;-&#123;&#123;name&#125;&#125;\n\</span></span><br><span class="line"><span class="string">  tasks:\n\</span></span><br><span class="line"><span class="string">    - name: copy captain.jar\n\</span></span><br><span class="line"><span class="string">      copy:\n\</span></span><br><span class="line"><span class="string">        src: /home/ci/captain/captain.jar\n\</span></span><br><span class="line"><span class="string">        dest: &#123;&#123;captain.path&#125;&#125;/\n\</span></span><br><span class="line"><span class="string">    - name: restart captain\n\</span></span><br><span class="line"><span class="string">      shell: bash &#123;&#123;captain.path&#125;&#125;/restart-captain.sh\n\</span></span><br><span class="line"><span class="string">'</span>)</span><br><span class="line"> </span><br><span class="line">yml = template.render(model)</span><br></pre></td></tr></table></figure>
<p>对于 Jinja2 的使用当然是强烈推荐的，在运维工作中掌握 Jinja2 的使用对于运维自动化的推进非常有帮助的</p>
<h4 id="序列解析及生成表达式"><a href="#序列解析及生成表达式" class="headerlink" title="序列解析及生成表达式"></a>序列解析及生成表达式</h4><p>这一部分也是 Python 中处理序列数据时非常强大的一些功能，可以简洁优美地完成一些序列数据的变换，也就是通常所说的 Pythonic</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个生成命令的函数</span></span><br><span class="line">In [<span class="number">7</span>]: <span class="function"><span class="keyword">def</span> <span class="title">ps_cmd</span><span class="params">(x)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">return</span> <span class="string">'ps -ef|grep %s'</span> % (x)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: datas = [<span class="string">'lc-auth'</span>, <span class="string">'lc-cmdb'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有元素执行方法并生成列表</span></span><br><span class="line">In [<span class="number">9</span>]: [ps_cmd(x) <span class="keyword">for</span> x <span class="keyword">in</span> datas]</span><br><span class="line">Out[<span class="number">9</span>]: [<span class="string">'ps -ef|grep lc-auth'</span>, <span class="string">'ps -ef|grep lc-cmdb'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 map 方法</span></span><br><span class="line">In [<span class="number">10</span>]: map(ps_cmd,datas)</span><br><span class="line">Out[<span class="number">10</span>]: [<span class="string">'ps -ef|grep lc-auth'</span>, <span class="string">'ps -ef|grep lc-cmdb'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于这类序列的处理，还需要掌握 map, filter, reduce 这三个函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用 lambda 表达式来处理</span></span><br><span class="line">In [<span class="number">11</span>]: map(<span class="keyword">lambda</span> x: <span class="string">'ps -ef|grep %s'</span> % x, datas)</span><br><span class="line">Out[<span class="number">11</span>]: [<span class="string">'ps -ef|grep lc-auth'</span>, <span class="string">'ps -ef|grep lc-cmdb'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 tuple 的列表处理, 将 tuple 转成字典存储结构</span></span><br><span class="line">In [<span class="number">17</span>]: [&#123;<span class="string">'username'</span>: x, <span class="string">'password'</span>: y&#125; <span class="keyword">for</span> x, y <span class="keyword">in</span> userlist]</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">[&#123;<span class="string">'password'</span>: <span class="string">'000000'</span>, <span class="string">'username'</span>: <span class="string">'user'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'username'</span>: <span class="string">'admin'</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'username'</span>: <span class="string">'ops'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成以用户名作为键值的字典</span></span><br><span class="line">In [<span class="number">18</span>]: userdatas = [&#123;<span class="string">'username'</span>: x, <span class="string">'password'</span>: y&#125; <span class="keyword">for</span> x, y <span class="keyword">in</span> userlist]</span><br><span class="line">In [<span class="number">20</span>]: &#123;item[<span class="string">'username'</span>]:item <span class="keyword">for</span> item <span class="keyword">in</span> userdatas&#125;</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">&#123;<span class="string">'admin'</span>: &#123;<span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'username'</span>: <span class="string">'admin'</span>&#125;,</span><br><span class="line"> <span class="string">'ops'</span>: &#123;<span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'username'</span>: <span class="string">'ops'</span>&#125;,</span><br><span class="line"> <span class="string">'user'</span>: &#123;<span class="string">'password'</span>: <span class="string">'000000'</span>, <span class="string">'username'</span>: <span class="string">'user'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器，可以看到上面的例子中外面都是以 [] 来表达的，这样会直接生成一个列表，但如果改为 () 的话可以创建生成器</span></span><br><span class="line">In [<span class="number">26</span>]: (ps_cmd(x) <span class="keyword">for</span> x <span class="keyword">in</span> datas)</span><br><span class="line">Out[<span class="number">26</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f0ef1339be0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: gen = (ps_cmd(x) <span class="keyword">for</span> x <span class="keyword">in</span> datas)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: gen</span><br><span class="line">Out[<span class="number">28</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f0ef1339c80</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: gen.next()</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">'ps -ef|grep lc-auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器也可以通过 for 语句或者 map, filter, reduce 等方法来遍历</span></span><br><span class="line"><span class="comment"># 生成器与列表的区别主要是列表在创建时需要分配内存，而生成器不需要，用来减少内存开销，这一特性通过 yield 关键字来实现</span></span><br><span class="line"><span class="comment"># 上面创建生成器的语句 (ps_cmd(x) for x in datas) 等价于</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(datas)</span>:</span></span><br><span class="line">   ....:     <span class="keyword">for</span> x <span class="keyword">in</span> datas:</span><br><span class="line">   ....:         <span class="keyword">yield</span> ps_cmd(x)</span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>使用 traceback 追踪错误, 例如打印调用栈<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do something</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="keyword">print</span> ex</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure></p>
<p>了解标准库中异常的层级结构，知道异常的一些分类方法，合理地进行错误处理使程序更健壮<br><a href="https://docs.python.org/2.7/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">https://docs.python.org/2.7/library/exceptions.html#exception-hierarchy</a><br>简化列举一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">  StandardError</span><br><span class="line">  	IOError (I/O 包括文件系统，网络等)</span><br><span class="line">  	OSError (系统相关)</span><br><span class="line">  	LookupError (访问数组/字典)</span><br><span class="line">  	TypeError (方法接收了不合法的类型等)</span><br><span class="line">  	ValueError (编解码相关)</span><br></pre></td></tr></table></figure></p>
<p>特殊的场景中也需要自定义异常，需要注意在自定义异常时也需要合理地定义异常的层级及父异常</p>
<h4 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h4><p>静态方法和类方法的使用，静态方法的定义通过 staticmethod 装饰器，类方法通过 classmethod 装饰器</p>
<p>常见的一种用法是定义一个工具类, 将一系列的方法归类，和直接使用函数的差别主要是在这些方法有了一个类的命名空间，管理起来不那么混乱<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(text)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(text)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>另外一种场景就是用于设置和该类相关的一些全局配置，环境变量等操作<br>类方法的使用和静态方法基本类似，区别在于接受的第一个参数是类的class对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span><span class="params">(object)</span>:</span></span><br><span class="line">    DEFAULT_LIMIT = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, offset, limit, keyword)</span>:</span></span><br><span class="line">        self.offset = <span class="number">0</span></span><br><span class="line">        self.limit = <span class="number">0</span></span><br><span class="line">        self.keyword = keyword</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(cls, limit)</span>:</span></span><br><span class="line">        <span class="comment"># 改变类的全局选项</span></span><br><span class="line">        cls.DEFAULT_LIMIT = limit</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_keyword</span><span class="params">(cls, keyword)</span>:</span></span><br><span class="line">        <span class="comment"># 通过 cls 参数来创建一个查询对象</span></span><br><span class="line">        <span class="keyword">return</span> cls(<span class="number">0</span>, DEFAULT_LIMIT, keyword)</span><br><span class="line"></span><br><span class="line">query = Query.from_keyword(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用抽象类及接口"><a href="#使用抽象类及接口" class="headerlink" title="使用抽象类及接口"></a>使用抽象类及接口</h4><p>使用 abc 库定义抽象类，可以在Python实例化类的时候检查类是否实现了某些方法，这样可以在一定程度上避免运行时调用接口导致 AttributeError 异常<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProcess</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'start a process'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'stop a process'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringbootProcess</span><span class="params">(AbstractProcess)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样就对 AbstractProcess 的子类进行了约束, 没有实现 start, stop 方法的类不能被实例化</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"example.py"</span>, line <span class="number">97</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    proc = SpringbootProcess(<span class="string">'xxx'</span>)</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class SpringbootProcess with abstract methods start, stop</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h4><p>Python中的类可以多重继承，但在面向对象原则上在继承的使用上必须保持单一继承关系，也就是一个类只能继承一个父类。<br>类比其他编程语言中的类可以实现多个接口，Python中的多重继承可以通过Mixin模式为类添加多种功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化并且通过Redis读取</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">redis_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_redis</span><span class="params">(cls, key)</span>:</span></span><br><span class="line">        r = redis.Redis(host=<span class="string">'192.168.100.101'</span>, port=<span class="number">6379</span>)</span><br><span class="line">        data = r.get(key)</span><br><span class="line">        <span class="keyword">return</span> pickle.loads(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_redis</span><span class="params">(self)</span>:</span></span><br><span class="line">        r = redis.Redis(host=<span class="string">'192.168.100.101'</span>, port=<span class="number">6379</span>)</span><br><span class="line">        data = pickle.dumps(self)</span><br><span class="line">        r.set(self.redis_key, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户类, 并提供序列化到Redis的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(RedisMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, email)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.email = email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">redis_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'username:%s'</span> % (self.name)</span><br><span class="line"></span><br><span class="line">user = User(<span class="string">'user'</span>, <span class="string">'user@xiaopeng.com'</span>)</span><br><span class="line">print(user.to_redis())</span><br><span class="line"></span><br><span class="line">user = User.from_redis(<span class="string">'username:user'</span>)</span><br><span class="line">print(user.name, user.email)</span><br></pre></td></tr></table></figure></p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>装饰器的应用主要在一些开发框架中，例如 Web 框架中的路由<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.router_mapper = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里定义装饰器, 将URI注册到对象中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(callfunc)</span>:</span></span><br><span class="line">            self.router_mapper[path] = callfunc</span><br><span class="line">            <span class="keyword">return</span> callfunc</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, uri, kwargs=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.router_mapper[uri](**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = Application()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @app.route('/hello')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @app.route('/echo')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'echo %s'</span> % (message)</span><br><span class="line"></span><br><span class="line">    print(app.dispatch(<span class="string">'/hello'</span>))</span><br><span class="line">    print(app.dispatch(<span class="string">'/echo'</span>, &#123;<span class="string">'message'</span>: <span class="string">'test'</span>&#125;))</span><br></pre></td></tr></table></figure></p>
<p>大家也可以拓宽思路, 将装饰器其使用在脚本里或者开发一些公共的运维模块</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2015/04/03/2015/2015-04-03-redis-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/03/2015/2015-04-03-redis-study/" itemprop="url">Redis学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-03T00:30:00+00:00">
                2015-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人笔记/" itemprop="url" rel="index">
                    <span itemprop="name">个人笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2015/04/03/2015/2015-04-03-redis-study/" class="leancloud_visitors" data-flag-title="Redis学习笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在NoSQL也是特别热门的技术关键词了，近来整理了一些Redis的东西</p>
<h2 id="数据对象与键空间"><a href="#数据对象与键空间" class="headerlink" title="数据对象与键空间"></a>数据对象与键空间</h2><p>Redis支持的数据类型比较多： 字符串，列表，哈希表，集合，有序集合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符串进行操作</span></span><br><span class="line">redis&gt; set message <span class="string">"hello world"</span></span><br><span class="line"><span class="comment"># 对列表进行操作</span></span><br><span class="line">redis&gt; rpush alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line"><span class="comment"># 对哈希表进行操作</span></span><br><span class="line">redis&gt; hset book name <span class="string">"Redis in action"</span></span><br><span class="line">redis&gt; hset book author <span class="string">"Josiah L. Carlson"</span></span><br><span class="line">redis&gt; hset book publisher <span class="string">"Manning"</span></span><br></pre></td></tr></table></figure>
<p>像上面的操作，在Redis的某个键空间里有三个键值分别是message, alphabet, book，指针分别指向不同的存储对象</p>
<p>而在book所指向的哈希表对象里面，又有它自己的键空间: name, author, publisher 指向字符串对象</p>
<p>在哈希表对象的键值，可以嵌套其他的数据对象，列表，集合，甚至再嵌套一个哈希表在里面</p>
<h2 id="过期键的处理"><a href="#过期键的处理" class="headerlink" title="过期键的处理"></a>过期键的处理</h2><p>在Redis里面可以对存储对象设置一个过期时间，当超过一定时间后，Redis会将这个键从数据库中自动删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置10秒的过期时间</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire msg <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="comment"># 进行查询</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get msg</span><br><span class="line"><span class="string">"wait expired"</span></span><br><span class="line"><span class="comment"># 等待几秒后再次查询</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get msg</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h2 id="RDB对过期键的处理策略"><a href="#RDB对过期键的处理策略" class="headerlink" title="RDB对过期键的处理策略"></a>RDB对过期键的处理策略</h2><p><strong>生成RDB文件时对过期键的处理:</strong></p>
<p>执行SAVE或者BGSAVE操作时，会将数据库保存至RDB文件中</p>
<p>Redis会对内存中的Key进行检查，已经过期的Key不会被保存到RDB文件中</p>
<p><strong>载入RDB文件时对过期键的处理：</strong></p>
<p>如果以主模式载入，则过期键不会被载入到内存数据库中</p>
<p>如果以从模式载入，过期键先会被载入到内存数据库中，而后主从同步时才对过期键进行清空</p>
<h2 id="AOF对过期键的处理"><a href="#AOF对过期键的处理" class="headerlink" title="AOF对过期键的处理"></a>AOF对过期键的处理</h2><p>当过期键被删除后，向AOF追加一条DEL命令用于标志已删除</p>
<p>如果客户端通过GET message访问一个过期键</p>
<p>1.服务器先删除message键</p>
<p>2.追加一条DEL message到AOF文件</p>
<p>3.返回空给客户端</p>
<p>和RDB相似，重写时会先对内存中的Key进行检查以确认是否写入AOF文件</p>
<h2 id="RDB持久化方式"><a href="#RDB持久化方式" class="headerlink" title="RDB持久化方式"></a>RDB持久化方式</h2><p>默认保存在dump.rdb文件中(/var/lib/redis/dump.rdb)<br>可以根据配置文件修改<br>dbfilename dump.rdb</p>
<p><strong>SAVE和BGSAVE</strong></p>
<p>SAVE: 由主进程直接写RDB，直到文件创建完毕(主进程阻塞)</p>
<p>BGSAVE: 后台保存, 执行一次fork，令子进程写RDB文件</p>
<p>这两种保存方式都可理解为是服务器被动保存，也就是服务器在接受到客户端发来的上面两条命令之后进行保存</p>
<p><strong>自动保存的实现</strong></p>
<p>在/etc/redis/redis.conf配置文件中定义保存条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>在seconds时间内 如果发生changes以上次修改时进行自动保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">    long long dirty;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在源码实现中，使用redisServer定义了一个全局变量server，其中有个dirty变量是用来记录修改次数的</p>
<p>那么在实现具体数据结构时，在操作改写存储对象的命令里面，就需要对dirty这个变量进行修改了，通常都是<br>执行server.dirty++的操作来进行，但是如果是对列表插入了两个元素这种情况，就要执行server.dirty+=n了</p>
<p>在源码实现中，serverCron是一个时间事件处理器(100ms执行一次)，在这里面就需要对配种中定义的保存条件<br>进行检查操作，如果满足条件时，Redis将创建一个子进程进行保存操作，在执行保存期间，如果客户端发过来保存<br>命令的话，服务器先检查到有一个子进程在进行保存操作，就不会处理这条命令了</p>
<h2 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h2><p>相关的配置选项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否设置为AOF持久化方式</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment">#默认的文件名</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"><span class="comment">#将aof_buf缓冲区中的所有内容写入并同步到 AOF 文件</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="comment">#将aof_buf缓冲区中的所有内容写入到 AOF 文件, 每秒进行同步</span></span><br><span class="line">appendfsync everysec </span><br><span class="line"><span class="comment">#将aof_buf缓冲区中的所有内容写入到 AOF 文件, 由操作系统决定同步</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure>
<p>aof_buf是一个缓冲区，如果工作在AOF模式下，服务器执行命令时会将该命令先写入缓冲区中，如果缓冲区满了<br>就将缓冲区的数据写入到AOF文件中，此时再清空缓冲区，继续执行其他命令，如此下去…</p>
<p>由于AOF根据每条命令生成存储记录，因而一个某个数据被重复修改时造成了数据冗余,其中一种<br>解决方案时定期根据内存中的值进行重写，同时也将过期键过滤掉，这一操作由后台进程运行</p>
<p><strong>AOF重写</strong></p>
<p>为了避免重写AOF主进程阻塞的情况，AOF将这一操作放在后台运行</p>
<p>1.创建子进程重写AOF，同时创建AOF缓存</p>
<p>2.子进程写AOF，主进程继续执行请求，同时写入AOF缓存</p>
<p>3.主进程检查子进程状态，子进程写结束后，主进程将AOF缓存追加到AOF文件中</p>
<p><strong>AOF重写的触发条件</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"><span class="comment">#min-size 表示最小大小，当AOF文件大于这个值时进行第一次重写操作</span></span><br><span class="line"><span class="comment">#percentage表示增量(默认100)，当AOF文件增量超过这个值时触发一次重写操作</span></span><br></pre></td></tr></table></figure>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Redis服务器可以复制一个主服务器作为备份的从服务器，复制后的从服务器对客户端而言是只读的<br>(实际上它只接受主服务器通过命令传播发过来的写操作)</p>
<p>通过下面的一条命令即可完成复制<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure></p>
<p>同步：将主服务器数据库状态更新到从服务器</p>
<p>命令传播：将主服务器的变更操作更新到从服务器(解决数据不一致问题)</p>
<p><strong>同步过程大概可以描述如下</strong></p>
<p>1.从服务器发送同步命令(SYNC)给主服务器</p>
<p>2.主服务器创建子进程发送RDB文件给从服务器，同时继续执行其他命令(保存在缓冲区)</p>
<p>3.主服务器将缓冲区中的所有写命令发送给从服务器</p>
<p>这一过程非常类似于AOF重写的过程</p>
<p>在完成同步后，其他到操作就通过命令传播来进行，就是当主服务器发生变更时，也需要将该条<br>写命令发送给从服务器去执行</p>
<p><strong>部分重同步</strong></p>
<p>从服务器可以在主从服务器之间的连接断开时进行自动重连,在2.8版本前，断线之后重连的从服务<br>器总要执行一次完整重同步, 2.8以后的版本中从服务器可以根据主服务器的情况来选择执行完整<br>重同步还是部分重同步</p>
<p>(主服务器ID，复制便宜量OFFSET) 记录在主服务器中</p>
<p>(主服务器ID) 从服务器检查连接的服务器是否和这个ID一致，如果是的话则通知主服务器从OFFSET开始复制数据</p>
<h2 id="Sentinel故障迁移"><a href="#Sentinel故障迁移" class="headerlink" title="Sentinel故障迁移"></a>Sentinel故障迁移</h2><p>Sentinel可以监控服务器的运行状态，并且支持自动选取一个从服务器作为主服务器</p>
<p>启动方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>也可以在一台机器上演示这个故障迁移的过程，默认的redis服务器作为主服务器，同时修改配置文件启动一个<br>工作在6380端口的服务器复制主服务器作为从服务器</p>
<p>然后写一个最简单sentinel配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor master <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">1</span></span><br><span class="line">sentinel down-after-milliseconds master <span class="number">60000</span></span><br><span class="line">sentinel failover-timeout master <span class="number">90000</span></span><br><span class="line">sentinel parallel-syncs master <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">sentinel monitor resque <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span> <span class="number">1</span></span><br><span class="line">sentinel down-after-milliseconds resque <span class="number">10000</span></span><br><span class="line">sentinel failover-timeout resque <span class="number">180000</span></span><br><span class="line">sentinel parallel-syncs resque <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这样先启动主服务器, 再启动复制主服务器的从服务器，然后启动sentinel进行监控； 这时候用kill将主服务器<br>关掉，就可以观察到6380的从服务器切换成服务器了，之后再启动6379端口的服务器，它也已经作为从服务器存在了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2015/03/16/2015/2015-03-16-python-decorator-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/16/2015/2015-03-16-python-decorator-thread/" itemprop="url">使用装饰器包装多线程程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-16T00:30:00+00:00">
                2015-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2015/03/16/2015/2015-03-16-python-decorator-thread/" class="leancloud_visitors" data-flag-title="使用装饰器包装多线程程序">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python中的装饰器的实质上是一个函数，它以其他函数作为参数来传递</p>
<p>在使用装饰器语法来定义一个函数的时候</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    ...</span></span><br></pre></td></tr></table></figure>
<p>实际上这个装饰器会对function函数进行一次调用</p>
<p>拆开来就是这样子了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function"><span class="title">Decorator</span><span class="params">(function)</span></span></span><br></pre></td></tr></table></figure>
<p>那么它有什么作用呢，现在看一个在多线程使用的例子</p>
<p>这里主要是利用装饰器对线程进行初始化，通过消息队列来传递参数</p>
<p>那么我用到这个装饰器来定义一个函数时，那么它就是由线程去执行的，我就不用关心线程的初始化动作了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue = Queue.Queue(<span class="number">10</span>)</span><br><span class="line"><span class="meta">@Thread(queue, 2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a+b=%s'</span>%(a+b)</span><br></pre></td></tr></table></figure>
<p>上面的代码我定义了一个测试线程，首先我创建了一个消息队列，然后描述线程的行为</p>
<p>在这里Thread(queue, 2)的意义是线程通过queue来获取参数，程序会创建2个线程去执行下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Thread</span><span class="params">(Q, threads = <span class="number">1</span>, interval = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(callfunc)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                kwargs = Q.get()</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'Thread %s Run...'</span> % (thread.get_ident())</span><br><span class="line">                json = callfunc(**kwargs)</span><br><span class="line">                time.sleep(interval)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, threads):</span><br><span class="line">            thread.start_new_thread(process, ())</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>
<p>现在看装饰器的代码</p>
<p>有三个参数Q，thread，interval分别意味着消息队列，线程数，执行间隔</p>
<p>这些变量可以简单地用来描述一段代码令其多线程执行</p>
<p>1.这边返回值是一个名为decorator的函数，也就是所谓的装饰器(他的参数是被装饰的那个函数callfunc)</p>
<p>2.然后还需对其处理一下，定义一个process的嵌套函数，这是一个无穷循环(也就是线程里执行的函数)</p>
<p>3.先通过Q从消息队列里抓取参数，如果有参数就调用callfunc去执行(在这里应该加入一个线程的终止条件的，我已经省略了), 在这里线程程序就完成了一次函数调用了，然后用sleep将自己挂起一定时间，当然也可以设置为0</p>
<p>4.在装饰器的最后，需要对线程进行创建，创建后消息队列是空的，那么每个线程就自动将自己设置成挂起状态了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Thread(queue, 2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a+b=%s'</span>%(a+b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        queue.put(&#123;<span class="string">'a'</span>: i, <span class="string">'b'</span>: i*<span class="number">2</span>&#125;)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    producer()</span><br></pre></td></tr></table></figure>
<p>回到主程序的代码，现在已经定义了testThread是一段由两个线程去执行它的代码</p>
<p>后面定义了一个生产者程序，往消息队列里放东西，这样在生产者运行后，消费者线程也就从消息队列中获取到参数去处理了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2015/01/31/2015/2015-01-31-python-introspection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/31/2015/2015-01-31-python-introspection/" itemprop="url">Python中的自省和反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-31T00:20:00+00:00">
                2015-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2015/01/31/2015/2015-01-31-python-introspection/" class="leancloud_visitors" data-flag-title="Python中的自省和反射">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><p>按照本人的理解，自省和反射机制是一个相似的概念，就拿反射来说，可能我在编程中遇到了这么一种情况：我(操作者)不知道需要操作的对象的数据结构和方法是怎么样的，但是我可以通过字符串的形式来令某个对象去调用某个方法，这就是一个简单的反射例子。 那么自省呢，我认为它是编程语言中的一个对象，它事先可以告诉我(或者说我可以通过某个方法了解到)它的结构是怎么样的，有哪些操作方法，然后我再去调用它，这就对编程者提供了一种很灵活的控制能力，也或者说它为实现反射提供了一种支持… </p>
<h2 id="Python中的自省"><a href="#Python中的自省" class="headerlink" title="Python中的自省"></a>Python中的自省</h2><p>灵活的自省和反射机制也是Python的一个重要的优点之一，编程者可以通过一些内建函数和方法实现对Python虚拟机层面的一些操作，因为默认情况下我们是通过写好的代码来对对象进行操作的，而对于虚拟机来说，代码就是被编译解释的字符串，然而Python虚拟机提供了可以直接通过字符串来操作对象的接口，因而就具备了良好的自省和反射。</p>
<h3 id="相关的内建函数"><a href="#相关的内建函数" class="headerlink" title="相关的内建函数"></a>相关的内建函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ID, name, age)</span>:</span></span><br><span class="line">        self.ID = ID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'I am a Student'</span></span><br></pre></td></tr></table></figure>
<p>这边定义了一个Student类，后面来对它进行自省和反射的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = Student(<span class="number">0</span>,<span class="string">'Li Lei'</span>,<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(Student)</span><br><span class="line">[<span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'say'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(ss)</span><br><span class="line">[<span class="string">'ID'</span>, <span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>, <span class="string">'say'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ss)</span><br><span class="line">&lt;type <span class="string">'instance'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Student)</span><br><span class="line">&lt;type <span class="string">'classobj'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(ss,Student)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>这边创建了一个Student的实例，然后我两次分别通过dir()对类和实例进行查看，从输出结果可以看到我收集到了关于这个类和第一个实例的部分属性名，通过type()内建函数也可以看到它们一个是instance类型,一个是classobj类型，通过isinstance()也可以判断一个对象是否是某个类创建的实例</p>
<p>从上面的dir()看到的属性也只是一部分，还有些是隐藏的，比如__class__和__dict__</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> <span class="title">student</span>.<span class="title">Student</span> <span class="title">at</span> 0<span class="title">x7f55ef61b328</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(ss.__class__)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">type</span> '<span class="title">classobj</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">ss</span>.<span class="title">__dict__</span></span></span><br><span class="line">&#123;'age': 20, 'ID': 0, 'name': 'Li Lei'&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.__class__.__dict__</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'student'</span>, <span class="string">'say'</span>: &lt;function say at <span class="number">0x7f55ef625de8</span>&gt;, <span class="string">'__init__'</span>: &lt;function __init__ at <span class="number">0x7f55ef625d70</span>&gt;, <span class="string">'__doc__'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以看出，__class__属性就是该对象的类（classobj)</p>
<p>实例(instance)和类(classobj)的属性都是通过__dict__这个字典来维护的</p>
<p>实例（instance)的__dict__里维护了学生的信息，也就是我在__init__()里定义的东西，这些东西在创建实例的时候被加到字典里</p>
<p>类(classobj)的__dict__维护了相关的方法，__init__和我自己定义的say()</p>
<p>这也就说明了对象方法的一个调用顺序</p>
<p>比如我执行ss.say()的时候，是从类(classobj)里找到这个方法，然后解释器再把自己通过self传入去执行</p>
<p>当然，我也有更奇葩的一种写法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.__class__.__dict__[<span class="string">'say'</span>]()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: say() takes exactly <span class="number">1</span> argument (<span class="number">0</span> given)</span><br></pre></td></tr></table></figure></p>
<p>这样就报错了，因为我没有将具体的实例(instance)作为参数传入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.__class__.__dict__[<span class="string">'say'</span>](ss)</span><br><span class="line">I am a Student</span><br></pre></td></tr></table></figure></p>
<p>现在将ss作为实例传进去，那么就执行成功了，这边的’say’我是通过字符串传入的，也就是完成动态调用的反射了</p>
<p>然后我要给Student加一个自杀的操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">selfkill</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'I going to kill myself, and my name is %s'</span>%(s.name)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.__dict__[<span class="string">'selfkill'</span>]=selfkill</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.selfkill()</span><br><span class="line">I going to kill myself, <span class="keyword">and</span> my name <span class="keyword">is</span> Li Lei</span><br></pre></td></tr></table></figure></p>
<p>这边我新建了一个函数，打印一行信息，并且取了name这个属性，把它放到Student的字典里</p>
<p>然后我用ss.selfkill()就可以调用它了，这样就完成了动态添加属性的反射了</p>
<p>但是没有人会在编程时这么做(如果我的同事这样写代码，我会打死他的)</p>
<p>通用的做法是这样的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(ss, <span class="string">'say'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(ss, <span class="string">'say'</span>)()</span><br><span class="line">I am a Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(ss, <span class="string">'sing'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'My name is %s'</span>%(s.name)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> sing</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(ss, <span class="string">'sing'</span>, wrapper(ss))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss.sing()</span><br><span class="line">My name <span class="keyword">is</span> Li Lei</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hh = Student(<span class="number">2</span>,<span class="string">"Han MeiMei"</span>,<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(hh,<span class="string">'sing'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>1.通过hasattr(x, attr)函数检查某个对象x是否有某个属性attr</p>
<p>2.通过getattr(x, attr)来读某个x对象的属性attr，如果是函数方法，就得加上括号和参数了getattr(x,attr)()</p>
<p>3.在上面的代码中通过包装器wrapper(s)来创建sing()这个方法，包装器在这边的作用就相当与是帮助传入self参数</p>
<p>4.后面创建的另一个学生韩梅梅(hh)就没有sing()这个方法，因为刚刚的sing()是动态为李雷(ss)这个实例添加的，当然也可以为Student这个类加入一个属性，那么每个新创建的实例都能调用sing()这个方法了，这里也不介绍了</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>需要区分的几个概念，因为Python虚拟机需要维护一个用来记录用户自定义类(class)的classobject, 因而需要理清从虚拟机到用户代码的这四个层次关系:</p>
<p>用户类(class)的类型: classobject [虚拟机(typeobject)]</p>
<p>用户类(class)的类的实例: 一个由classobject创建的实例, Student类 [虚拟机(typeobject)]</p>
<p>用户类: Student [用户代码]</p>
<p>用户类的实例: 由Student创建的实例 [用户代码]</p>
<p>这部分内容可以阅读Python相关源代码的具体实现，看懂部分后就对这个机制有个很明了的理解啦</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2014/12/21/2014/2014-12-21-python-threading-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/12/21/2014/2014-12-21-python-threading-study/" itemprop="url">Python多线程编程学习之基础篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-12-21T03:20:00+00:00">
                2014-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2014/12/21/2014/2014-12-21-python-threading-study/" class="leancloud_visitors" data-flag-title="Python多线程编程学习之基础篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要介绍Python使用threading模块进行多线程编程的例子，以及一个简单的线程池的实现思路。</p>
<p>具体可以参考该模块的<a href="https://docs.python.org/2/library/threading.html#threading.Condition" target="_blank" rel="noopener">官方文档</a></p>
<p>##线程的创建和使用、锁、条件变量##</p>
<p><strong>线程创建</strong></p>
<p>Python的threading模块提供了两种创建线程的方法</p>
<p>方法一是直接使用threading.Thread()来创建，在这种创建方式中，创建Thread()对象时需要指定该线程准备执行的函数，然后用<br>*args与**kwargs来传递参数，其中*args传递一个tuple类型的参数，**kwargs传递字典类型的参数表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_print_args</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">print</span> args, kwargs</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_create_test</span><span class="params">()</span>:</span></span><br><span class="line">    threading.Thread(<span class="keyword">None</span>, thread_print_args, args = (<span class="string">'a1'</span>,<span class="string">'a2'</span>), kwargs = &#123;<span class="string">'name'</span>: <span class="string">'test'</span>&#125;).start()</span><br><span class="line">    threading.Thread(<span class="keyword">None</span>, thread_print_args, args = (<span class="string">'b1'</span>,<span class="string">'b2'</span>), kwargs = &#123;<span class="string">'name'</span>: <span class="string">'hello'</span>&#125;).start()</span><br></pre></td></tr></table></figure></p>
<p>方法二是通过自定义线程类继承threading.Thread类来创建，需要重载run()方法，在run()方法中设置线程要跑的函数就行了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">print</span> self.name</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_create_test</span><span class="params">()</span>:</span></span><br><span class="line">    ThreadPrint().start()</span><br><span class="line">    ThreadPrint().start()</span><br></pre></td></tr></table></figure></p>
<p>可以参看threading.py文件中的源码，其实run()方法就是线程调度运行时要执行的函数，默认的Thread类里也是<br>通过self.__target来调用相应的函数，只是在构造对象时创建了这个属性</p>
<p>另外，不论使用哪种方式创建了线程，线程在run()方法执行完毕之后自动退出</p>
<p><strong>使用互斥锁</strong></p>
<p>互斥锁的用途是用于控制线程间共有资源的访问，实现原子操作，也不多介绍了</p>
<p>在Python中互斥锁被封装在threading.Lock这个类中，具有请求和释放两个方法</p>
<p>这边的例子是创建2个线程使用互斥锁对全局的count进行累加的操作，两个线程有不同的访问间隔:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mutex = threading.Lock()</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLockTest</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> count</span><br><span class="line">        <span class="keyword">while</span> count &lt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s acquires..."</span> % (self.name)</span><br><span class="line">            mutex.acquire()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s enter..."</span> % (self.name)</span><br><span class="line">            count = count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%s : %d'</span> %(self.name, count)</span><br><span class="line">            time.sleep(self.interval)</span><br><span class="line">            mutex.release()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s exit..."</span> % (self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_lock_test</span><span class="params">()</span>:</span></span><br><span class="line">    ThreadLockTest(<span class="number">0.1</span>).start()</span><br><span class="line">    ThreadLockTest(<span class="number">0.3</span>).start()</span><br></pre></td></tr></table></figure></p>
<p>该例子也只是简要地说明锁的使用方式，在实际的多线程编程中使用锁时，还得注意死锁的避免，一个简单的原则就是：保证线程都按相同的次序来持有锁变量</p>
<p><strong>使用条件变量</strong></p>
<p>条件变量是用于线程的同步的，简单地说就是去操作线程’挂起等待-唤醒’这一过程</p>
<p>Python中条件变量封装在threading.Condition这个类中，wait()方法用于阻塞等待，notify()方法用于唤醒，需要注意到的是对于条件变量的访问是原子的，因而条件变量也含有了acquire(),release()这两个方法，在使用wait()，notify()之前就需要先请求锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">condition = threading.Condition()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadCondTest</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%s runs.."</span> %(self.name)</span><br><span class="line">        condition.acquire()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"%s wait.."</span> %(self.name)</span><br><span class="line">        condition.wait()</span><br><span class="line">        condition.release()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Hi, I'm runs now"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cond_test</span><span class="params">()</span>:</span></span><br><span class="line">    ThreadCondTest().start()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    condition.acquire()</span><br><span class="line">    condition.notify()</span><br><span class="line">    condition.release()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，线程创建启动后马上将自己阻塞等待，直到主程序time.sleep(3)之后将其唤醒后继续执行后面的代码</p>
<p>##一个简单线程池的实现思路##</p>
<p>实际的多线程编程中，为了避免大量的创建和销毁线程，就需要建立一个线程池来辅助管理和回收利用这些线程来达到程序优化的目的；然而在Python中，相比与Linux下用C/C++来实现一个线程池的话，编程的复杂度就简单得多了；通常一个完整的线程池由线程池需要有线程队列和工作队列两个部分组成，这边简要介绍一个线程队列的实现思路作抛砖引玉用，当然如果要设计成通用的模块和API的话还是有大量的工作要做的</p>
<p>Python中的Queue模块已经提供了一个多线程环境下的队列应用(内部用互斥锁已经实现了原子访问)，可以直接拿起来用，就不必考虑设计队列时的互斥和同步问题了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">MAX_THREADS = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, poll, cond, num)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.poll = poll</span><br><span class="line">        self.task = <span class="keyword">None</span></span><br><span class="line">        self.task_args = <span class="keyword">None</span></span><br><span class="line">        self.cond = cond</span><br><span class="line">        self.threadID = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Thread: %s wait now...'</span>%(self.getName())</span><br><span class="line">            self.cond.acquire()</span><br><span class="line">            self.poll.threads.put(self)</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            self.cond.release()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'Thread: %s run now...'</span>%(self.getName())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.task != <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'Call Function : %s(%s)'</span> %(self.task, self.task_args)</span><br><span class="line">                self.task(self.task_args)</span><br><span class="line">                <span class="keyword">del</span> self.task, self.task_args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoll</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.threads = Queue.Queue(n)</span><br><span class="line">        self.maxsize = n</span><br><span class="line">        self.__init__threads()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__threads</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, self.maxsize):</span><br><span class="line">            thr = TestThread(poll = self, cond = threading.Condition(), num = i)</span><br><span class="line">            thr.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, func, arg)</span>:</span></span><br><span class="line">        thr = self.threads.get()</span><br><span class="line">        thr.task = func</span><br><span class="line">        thr.task_args = arg</span><br><span class="line">        thr.cond.acquire()</span><br><span class="line">        thr.cond.notify()</span><br><span class="line">        thr.cond.release()</span><br><span class="line">        <span class="keyword">return</span> thr.threadID</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_print</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Thread: %s'</span> % (s)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_poll_test</span><span class="params">()</span>:</span></span><br><span class="line">    threadpoll = ThreadPoll(MAX_THREADS)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-1'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-2'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-3'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-4'</span>)</span><br><span class="line"></span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-1'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-2'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-3'</span>)</span><br><span class="line">    threadpoll.dispatch(thread_print, <span class="string">'Test-4'</span>)</span><br></pre></td></tr></table></figure>
<p>TestThread类是线程池使用的线程类，其中task属性用于设置线程将要完成的任务，默认为空，使用时通过线程池的dispatch()来自动分派，<br>run()函数里是一个无穷循环，初始化时首先将自己阻塞挂起，之后放回到线程池中，统一由线程池进行管理。</p>
<p>ThreadPoll类是线程池的管理器，提供dispatch()来分派将要进行的任务给正在等待的线程，初始化时先创建N个线程，它们都统一阻塞自己放回到线程池中，如果有一个新的任务要做时，就通过dispatch()去分派，先是从队列中取出一个线程，给他重新设置task属性和参数，之后将其唤醒，那么该线程就会去执行这个工作，待它执行完之后又回到主循环，将自己放回线程池和进入等待状态。</p>
<p>进一步的工作还需要考虑工作队列模块，例如当一个新的task来的时候，如果线程池中没有空闲的线程池，那么就得先将该任务放进工作队列缓冲区中，而线程池中一旦有空闲线程，就得从工作队列中拉出一个task来处理</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sizeoftank.github.io/2014/08/24/2014/2014-08-24-python-source-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sizeoftank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sizeoftank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/24/2014/2014-08-24-python-source-object/" itemprop="url">Python源码分析：对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-24T09:47:09+00:00">
                2014-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2014/08/24/2014/2014-08-24-python-source-object/" class="leancloud_visitors" data-flag-title="Python源码分析：对象">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先要知道Python中的所有数据类型都是以对象来实现的，然而这个PyObject相当于是一个最顶层的抽象对象，它用来维护和操作Python中所有类型对象共同的信息和功能部分<br>描述对象的代码在object.h和object.c中可以看到~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>如这段代码中看到的，定义了一个对象的结构体<br>实际上并不会去以PyObject来声明一个对象(相当于是面向对象语言中的抽象类型）<br>但是任何对象的指针都可以转换成PyObject *，这相当与是用C语言手纯手写出来的继承关系</p>
<p>Python内部所有对象的实现的源码都位于Objects目录下：object.c, intobject.c, listobject.c, typeobject.c 等等<br>看Objects目录下面的代码会发现：<br>每个对象的结构体里面都含有PyObject_HEAD这个宏<br>实际上这个宏展开后是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PyObject_HEAD defines the initial segment of every PyObject. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_HEAD                   \</span></span><br><span class="line">    _PyObject_HEAD_EXTRA                \</span><br><span class="line">    Py_ssize_t ob_refcnt;               \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br></pre></td></tr></table></figure>
<p>其中ob_refcnt记录了对象的引用计数信息(Python的使用了引用计数算法来实现垃圾收集）</p>
<p>ob_type是一个_typeobject结构体(PyTypeObject，属于内部的特殊类型对象)，其中保存了对象的类型名称、需要分配的内存大小，对象的操作方法表(tp_methods)，以及一系列关于该对象的操作行为的函数指针（比如dealloc, print, compare等等)<br>那么Python在创建对象时就会用到这个全局变量了，把这个全局变量指针赋值给ob_type这个成员，至此一个Object就标记上了相应的‘身份’了，至于具体的每个对象如何去创建和删除，就可以去阅读相应类型的源码了(Objects目录下）</p>
<p>例如listobject.c中会创建一个PyList_Type全局变量(类似的在其他类型对象的.c文件中也会创建相应的全局变量)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyList_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"list"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyListObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (destructor)list_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    (printfunc)list_print,                      <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_compare */</span></span><br><span class="line">    (reprfunc)list_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    &amp;list_as_sequence,                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    &amp;list_as_mapping,                           <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    (hashfunc)PyObject_HashNotImplemented,      <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |</span><br><span class="line">    Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS,         <span class="comment">/* tp_flags */</span></span><br><span class="line">    list_doc,                                   <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)list_traverse,                <span class="comment">/* tp_traverse */</span></span><br><span class="line">    (inquiry)list_clear,                        <span class="comment">/* tp_clear */</span></span><br><span class="line">    list_richcompare,                           <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    list_iter,                                  <span class="comment">/* tp_iter */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_iternext */</span></span><br><span class="line">    list_methods,                               <span class="comment">/* tp_methods */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_members */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    (initproc)list_init,                        <span class="comment">/* tp_init */</span></span><br><span class="line">    PyType_GenericAlloc,                        <span class="comment">/* tp_alloc */</span></span><br><span class="line">    PyType_GenericNew,                          <span class="comment">/* tp_new */</span></span><br><span class="line">    PyObject_GC_Del,                            <span class="comment">/* tp_free */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过PyObject*指针访问这个成员不仅可以访问到对象的类型，并可以通过它访问ob_type之后对对象进行具体的操作，而具体操作的实现则由每个对象类型具体的代码中去做；实际上就相当于面向对象中抽象类和每个子类的关系，但是在C语言里面用了指针去实现的话阅读起来就显得复杂一些。</p>
<p>比如析构函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_Py_Dealloc(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    destructor dealloc = Py_TYPE(op)-&gt;tp_dealloc;</span><br><span class="line">    _Py_ForgetReference(op);</span><br><span class="line">    (*dealloc)(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这边就是使用 Py_TYPE(op)-&gt;tp_dealloc来获取具体的析构函数指针（Py_TYPE宏是用来访问成员ob_type的)<br>​<br>变长对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure></p>
<p>跟上面PyObject不同的是不同的变长对象占用的内存大小是不一样的，比如不同的list对象里元素个数是不一样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD               \</span></span><br><span class="line">    PyObject_HEAD                       \</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INVALID_SIZE (Py_ssize_t)-1</span></span><br></pre></td></tr></table></figure></p>
<p>PyObject_VAR_HEAD这个宏里面就是在PyObject_HEAD的基础上加上ob_size来描述变长对象的长度。</p>
<p>对比intobject和listobject的代码发现：<br>定义PyIntObject对象使用的是PyObject_HEAD这个宏，说明它是定长的（这边要注意区分普通整型数int和Python中的大整数的区别，大整数是基于变长对象来实现的），定义PyListObject对象使用的是PyObject_VAR_HEAD这个宏，说明它是变长的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sizeoftank</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sizeoftank" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/lovefar/" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sizeoftank</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>





  <script src="https://unpkg.com/mermaid@8.13.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"forest"});
    }
  </script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("tclzHvBInNDh45LdDgB99dS3-gzGzoHsz", "egATB3l5I1ctiULajrBzgABl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
